# *** WARNING: DO NOT MODIFY *** This is a generated Python source code!
#
# Generated by LF-ET 2.4.1 (260127a), https://www.lohrfink.de/lfet
# From decision table
# "E:/data/schweier/rbtfrmwrk/robotframework-syndata/lfet/ItemBuilderEngine.lfet"
# 13.02.2026 15:13
#
# Changes to this code resulting from refactorings can be synchronised
# with LF-ET using the function "Scrapbook Import".
#
# Prolog Decision Table ---->
# $$BasicIndentLevel=2
import pandas as pd
from faker import Faker

from robot.libraries.BuiltIn import BuiltIn
from .de_DE.item_builder_engine_germany import ItemBuilderEngineGermany
from .common.item_builder_engine_faker import ItemBuilderEngineFaker

class ItemBuilderEngine:

    def __init__(self):
        self.recorded_row = pd.Series([])
        self.recorded_data = None

    def get_recorded_testcase(self) -> str:
        if(self.recorded_row.empty):
            return None
        else:
            print(f"get_recorded_testcase(self): {self.recorded_row["test_case"]}")
            return self.recorded_row["test_case"]

    def iterate_to_next_row(self):
        if(0 < len(self.recorded_data)):
            self.recorded_data = self.recorded_data.iloc[1:]
            if(0 < len(self.recorded_data)):
                self.recorded_row = next(self.recorded_data.iterrows())[1]
            else:
                self.recorded_row["item"] = "unknown"
                self.recorded_row["value"] = ""
                self.recorded_row["keyword"] = "Unknown Keyword"

    def init_first_row(self, file):
        self.recorded_data = pd.read_csv(file, index_col="index")
        self.recorded_data = self.recorded_data.query(f"test_case == \"{BuiltIn().get_variable_value("${TEST NAME}")}\"")
        if(0 < len(self.recorded_data)):
            self.recorded_row = next(self.recorded_data.iterrows())[1]
        else:
            self.recorded_row = pd.Series(data={ "timestamp":"", "item":"unknown", "value": "", "test_suite": f"{BuiltIn().get_variable_value("${SUITE NAME}")}", "test_case": f"{BuiltIn().get_variable_value("${TEST NAME}")}", "keyword": ""}, index=["timestamp", "item", "value", "test_suite", "test_case", "keyword"])

    def execute(self, instance, localization: str, keyword: str, item: str, item_data: dict):
        # Prolog Decision Table <----
        # Condition B01/01: Current Mode / DEF / The default mode, in which random data is to be generated.
        if ( instance.MODE_DEF == instance.get_mode() ):
            # Condition B02/01: Context is / None / There is no set context.
            if ( None == instance.Get_Context() ):
                # Condition B06/01: Localization / de_DE / Germany
                if ( "de_DE" == localization ):
                    # Rule R01 ---->
                    # Trace ---->
                    instance.add_rbt_log_message("[SynData] Decision table ItemBuilderEngine (20260213.151300), rule 1 of 9 has been executed", "DEBUG")
                    # Trace <----
                    # Action A01/02: Call ItemBuilderEngine... / Germany / This item builder is responsible for german test data.
                    retval = ItemBuilderEngineGermany.execute(instance, localization, keyword, item, item_data)
                    # Action A03/01: Call for logging / local / The locally generated value should be transferred to the logging
                    instance.add_log_entry(keyword, item, retval)
                    # Action A06: Return data from ItemBuilderEngine...
                    return retval
                    # Rule R01 <----
                else:
                    # Rule R02 ---->
                    # Trace ---->
                    instance.add_rbt_log_message("[SynData] Decision table ItemBuilderEngine (20260213.151300), rule 2 of 9 has been executed", "DEBUG")
                    # Trace <----
                    # Action A01/01: Call ItemBuilderEngine... / Faker / If there is no reliable implementation for the defined localization, Faker is used as a substitute.
                    retval = ItemBuilderEngineFaker.execute(instance, localization, keyword, item, item_data)
                    # Action A03/01: Call for logging / local / The locally generated value should be transferred to the logging
                    instance.add_log_entry(keyword, item, retval)
                    # Action A06: Return data from ItemBuilderEngine...
                    return retval
                    # Rule R02 <----
            else:
                # Condition B03/01: Requested item is / unknown / The requested item has not yet been created within the context.
                if ( None == instance.get_item(item) ):
                    # Condition B06/01: Localization / de_DE / Germany
                    if ( "de_DE" == localization ):
                        # Rule R03 ---->
                        # Trace ---->
                        instance.add_rbt_log_message("[SynData] Decision table ItemBuilderEngine (20260213.151300), rule 3 of 9 has been executed", "DEBUG")
                        # Trace <----
                        # Action A01/02: Call ItemBuilderEngine... / Germany / This item builder is responsible for german test data.
                        retval = ItemBuilderEngineGermany.execute(instance, localization, keyword, item, item_data)
                        # Action A03/02: Call for logging / stored / The value should be read from the data structure for logging.
                        value = instance.get_item(item)
                        instance.add_log_entry(keyword, item, value)
                        # Action A06: Return data from ItemBuilderEngine...
                        return retval
                        # Rule R03 <----
                    else:
                        # Rule R04 ---->
                        # Trace ---->
                        instance.add_rbt_log_message("[SynData] Decision table ItemBuilderEngine (20260213.151300), rule 4 of 9 has been executed", "DEBUG")
                        # Trace <----
                        # Action A01/01: Call ItemBuilderEngine... / Faker / If there is no reliable implementation for the defined localization, Faker is used as a substitute.
                        retval = ItemBuilderEngineFaker.execute(instance, localization, keyword, item, item_data)
                        # Action A03/02: Call for logging / stored / The value should be read from the data structure for logging.
                        value = instance.get_item(item)
                        instance.add_log_entry(keyword, item, value)
                        # Action A06: Return data from ItemBuilderEngine...
                        return retval
                        # Rule R04 <----
                else:
                    # Rule R05 ---->
                    # Trace ---->
                    instance.add_rbt_log_message("[SynData] Decision table ItemBuilderEngine (20260213.151300), rule 5 of 9 has been executed", "DEBUG")
                    # Trace <----
                    # Action A03/02: Call for logging / stored / The value should be read from the data structure for logging.
                    value = instance.get_item(item)
                    instance.add_log_entry(keyword, item, value)
                    # Action A05: Return data stored in the current context
                    return instance.get_item(item)
                    # Rule R05 <----
        else:
            # Condition B04/01: Comparison current test case vs recorded test case / equal / In this case, it can be assumed that the iterator for the replay is initialized correctly.
            if ( BuiltIn().get_variable_value("${TEST NAME}") == self.get_recorded_testcase()):
                # Condition B05/01: Comparison current item vs recorded item / equal / In this case, the requested item corresponds to the one that was logged next in the recorded data.
                if (item == f"{self.recorded_row["item"]}"):
                    # Rule R06 ---->
                    # Trace ---->
                    instance.add_rbt_log_message("[SynData] Decision table ItemBuilderEngine (20260213.151300), rule 6 of 9 has been executed", "DEBUG")
                    # Trace <----
                    # Action A03/03: Call for logging / replay /
                    instance.add_log_entry(keyword, item, self.recorded_row["value"])
                    # Action A07/01: Return recorded data / direct / In this case, the return value is obtained directly from the recorded data.
                    retval = self.recorded_row["value"]
                    self.iterate_to_next_row()
                    return retval
                    # Rule R06 <----
                else:
                    # Condition B06/01: Localization / de_DE / Germany
                    if ( "de_DE" == localization ):
                        # Rule R07 ---->
                        # Trace ---->
                        instance.add_rbt_log_message("[SynData] Decision table ItemBuilderEngine (20260213.151300), rule 7 of 9 has been executed", "DEBUG")
                        # Trace <----
                        # Action A01/02: Call ItemBuilderEngine... / Germany / This item builder is responsible for german test data.
                        retval = ItemBuilderEngineGermany.execute(instance, localization, keyword, item, item_data)
                        # Action A03/01: Call for logging / local / The locally generated value should be transferred to the logging
                        instance.add_log_entry(keyword, item, retval)
                        # Action A04/01: Log warning / NOREP / This warning is issued if the requested item was not found in the recorded data. In this case, the return value is generated by a generator that is identified by the localization.
                        BuiltIn().log(f"SynData(NOREP): According to the data record, the keyword {self.recorded_row["keyword"]} was expected to be called. The return value therefore does not correspond to the recorded value, but to a generated value.", level="WARN")
                        # Action A06: Return data from ItemBuilderEngine...
                        return retval
                        # Rule R07 <----
                    else:
                        # Rule R08 ---->
                        # Trace ---->
                        instance.add_rbt_log_message("[SynData] Decision table ItemBuilderEngine (20260213.151300), rule 8 of 9 has been executed", "DEBUG")
                        # Trace <----
                        # Action A01/01: Call ItemBuilderEngine... / Faker / If there is no reliable implementation for the defined localization, Faker is used as a substitute.
                        retval = ItemBuilderEngineFaker.execute(instance, localization, keyword, item, item_data)
                        # Action A03/01: Call for logging / local / The locally generated value should be transferred to the logging
                        instance.add_log_entry(keyword, item, retval)
                        # Action A04/01: Log warning / NOREP / This warning is issued if the requested item was not found in the recorded data. In this case, the return value is generated by a generator that is identified by the localization.
                        BuiltIn().log(f"SynData(NOREP): According to the data record, the keyword {self.recorded_row["keyword"]} was expected to be called. The return value therefore does not correspond to the recorded value, but to a generated value.", level="WARN")
                        # Action A06: Return data from ItemBuilderEngine...
                        return retval
                        # Rule R08 <----
            else:
                # Rule R09 ---->
                # Trace ---->
                instance.add_rbt_log_message("[SynData] Decision table ItemBuilderEngine (20260213.151300), rule 9 of 9 has been executed", "DEBUG")
                # Trace <----
                # Action A02: Initialization of recorded data for the current test case
                self.init_first_row(instance.get_replay_file())
                # Action A07/02: Return recorded data / recursion / If the engine is not yet ready to provide recorded data, the engine is called again.
                return self.execute(instance, localization, keyword, item, item_data)
                # Rule R09 <----

# End of generated Python source code
# Generated by LF-ET 2.4.1 (260127a), https://www.lohrfink.de/lfet
