# import random
import datetime
import time
import os

import pandas as pd

from typing import Literal
from robot.api.deco import keyword, not_keyword, library
from robot.libraries.BuiltIn import BuiltIn

from item_builder_engine import ItemBuilderEngine

from common.country import Country

@library(scope='GLOBAL', version='0.0.2')
class SynData:
    """ 
    Test data is required in many projects. In some cases, the test data is 
    generated once and anchored in the test scripts. In other projects, 
    random test data is used so that each subsequent test run can increase 
    the test coverage in terms of variance.

    The following basic considerations led to the development of this 
    library:

    - _The library should manage data that has already been generated:_
      In some cases, a test date is required multiple times in a test case. 
      To do this, the test date can be stored in a variable and accessed 
      when needed. Another idea is for the library to remember what has been 
      generated and take over the management itself.
    - _Data should be consistent where possible:_
      There may be dependencies among the data generated by different 
      keywords. The keywords ``Get Name`` and ``Get First Name`` are a 
      simple example of consistent data. ``Get Name`` returns a string 
      consisting of a first name and a last name. From the perspective of 
      test data consistency, the first name in the return values of the 
      keywords is expected to be identical.
    - _Data should be as close to reality as possible:_
      For example, if an address is to be used in a test case, in Germany it 
      consists of a postal code and a city. This library is required to 
      ensure that the combination of postal code and city matches. This 
      requirement can only be guaranteed for localizations that have a 
      specialized generator.
    - _Test cases should be as easy as possible to repeat with data from a 
      previous test run:_
      If a test case fails during an automated test run, a tester wants to 
      be able to analyze the test case with the data that was used in the 
      test run. For this purpose, logging of the test data was provided, 
      and when the library is imported with a log file, the data is 
      simply "played back".

    == Use of context ==

    A context can be understood as a data space. In this data space, the library 
    remembers the data that is randomly generated and, when new data is to be 
    generated, ensures that the data is consistent.
    
    An example of the use of a context is a role or persona that is required in 
    the test case. In an online shop, this could be a customer, for example. 
    In the test case, a context with the name ``customer`` can be created, and 
    thus, for example, the first name is only randomly generated the first time 
    using ``Get First Name``. Each subsequent call to ``Get First Name`` returns 
    the first name that was generated the first time, as long as the context is 
    not left.
    
    Multiple contexts can also be created and automatically generated with 
    ``Set Context`` if the context does not exist. If a context is set that is 
    known to the library, it is reactivated. This allows you to switch between 
    contexts in the test case with ``Set Context``.

    == Log test data and replay it ==

    *This feature is not yet implemented in the library.*
    
    The goal is to log the keywords called and their return values during test 
    execution. The log file is created in the Robot Framework output directory.

    The path to one of these log files can be passed when importing the library. 
    If this happens, the library does not generate test data for the test cases 
    contained in the log file, but instead returns the values from the log file.
    """
    ROBOT_AUTO_KEYWORDS = False

    MODE_DEF = 0
    MODE_REP = 1

    INSTANCE = None

    def __init__(self, localization: str ="en_US", logging: bool =False, logfile: str =None, replayfile: str =None):
        """
        The constructor is used to initialize the library.

        | =Arguments=      | =Descripion= |
        | ``localization`` | The parameter can be used to specify the localization to be used if no context is set. The default value is ``en_US``. |
        | ``logging``      | This parameter can be used to enable the recording of test data. The default value is ``False``, which means that recording is disabled. |
        | ``logfile``      | During initialization, the caller can specify the name of the file for recording the test data. The specification is only evaluated if ``logging`` has the value ``True``. The default value is ``None``. In this case, the name is generated automatically. The format contains the date and time when the test was started. A concrete example might look like this: ``SynData-20260204-124643.log`` |
        | ``replayfile``   | The parameter can be used to pass the full path to a log file so that the file is set as the data source for the keywords. If a file name is transferred here, many functions of the library, such as context management, are overridden. The default value is ``None``, which means that the generators are used to generate data. |
        """
        self.context = None
        self.data = {}
        self.ibe = ItemBuilderEngine()
        self.rbt_bi = None
        if(None == replayfile):
            self.mode = SynData.MODE_DEF
            self.replayfile = None
        else:
            self.mode = SynData.MODE_REP
            self.replayfile = replayfile
        self.set_configuration(self.mode, localization, logging, logfile, replayfile)
        SynData.INSTANCE = self

    def get_keyword_names(self):
        # Get all attributes and their values from the library.
        attributes = [(name, getattr(self, name)) for name in dir(self)]
        # Filter out attributes that do not have 'robot_name' set.
        keywords = [(name, value) for name, value in attributes
                    if hasattr(value, 'robot_name')]
        # Return value of 'robot_name', if given, or the original 'name'.
        return [value.robot_name or name for name, value in keywords]


    #   ========================================================================
    #       Keywords for Mode-Management
    #   ========================================================================

    @staticmethod
    @keyword(tags=["Management"])
    def Set_SynData_Configuration(mode: Literal["default", "replay"] = "default", localization: str ="en_US", logging: bool =False, logfile: str =None , replay_file: str = None):
        """
        This keyword can be used to reset the library configuration.

        In principle, the library can also be configured using import 
        parameters. If a new test suite starts and a previous test suite has 
        initialized SynData, the import parameters of the current test suite 
        may be ignored because the library is not reinitialized.

        To be independent of a previous configuration, this keyword is 
        recommended instead of import parameters and can be called up in 
        the ``Suite Setup``, for example.

        The keyword has no effect on previously saved data.
        
        | =Arguments=      | =Descripion= |
        | ``mode``         | The caller can choose between ``default`` and ``replay`` here. The ``default`` mode, which is also the default value, should be selected if the library is to be used to generate test data. For the ``replay`` mode, the path to a log file must be passed in the “replay_file” parameter, from which the values used as return values for the keywords are then taken. This mode is suitable for repeating a test case with data from a previous test execution. |
        | ``localization`` | The parameter can be used to specify the localization for this context. The default value is ``en_US``. |
        | ``logging``      | The caller can use this parameter to control whether the generated data should be logged. The default value ``False`` disables logging. |
        | ``logfile``      | If logging has been enabled, the data is written to the Robot Framework output directory. Optionally, a file name can be specified; otherwise, the file name is generated from the date and time. |     
        | ``replay_file``  | If the value ``replay`` is passed in the ``mode`` parameter, this parameter must contain the full path to the log file from which the data is to be replayed. |     
        """
        SynData.INSTANCE.set_configuration(mode, localization, logging, logfile, replay_file)



    #   ========================================================================
    #       Keywords for Context-Management
    #   ========================================================================

    @staticmethod
    @keyword(tags=["Management"])
    def Set_Context(context: str, localization: str ='en_US', focus: Literal["global", "suite", "test"] ='test') -> str:
        """
        The keyword can be used to set a context.

        The context is a data space in which the test data is generated 
        consistently and the generated test data is stored.

        If there is no suitable context, the initial data structure for the 
        context is created and the context is set.

        A focus can be set for a context that describes the scope of validity of 
        the context. The following values are defined for the parameter 
        ``focus``:

        - ``global``: In this case, the context is available in all test suites 
          during test execution. This can be useful if there is a test date 
          that should be the same for all test cases.
        - ``suite``: In this case, the context is limited to one test suite. This 
          means that the data is available to all test cases that belong to the 
          test suite in which the context was created.
        - ``test``: In this case, the context is limited to the test case in which 
          it was created.

        | =Arguments=      | =Descripion= |
        | ``context``      | The name of the context is a string that describes the data space from a technical perspective. This parameter must contain a value. |
        | ``localization`` | The parameter can be used to specify the localization for this context. The default value is ``en_US``. |
        | ``focus``        | The parameter can be used to define the scope of the context. The valid values for this parameter are ``global``, ``suite``, and ``test``. The default value is ``test``, which means that the context is limited to the test case in which it is set. |
        """
        match focus.lower():
            case "global":
                context_id=f"global.{context}"
            case "suite":
                context_id=f"{SynData.INSTANCE.get_current_test_suite()}.{context}"
            case "test":
                context_id=f"{SynData.INSTANCE.get_current_test_suite()}.{SynData.INSTANCE.get_current_test_case()}.{context}"
            case _:
                context_id=f"global.{context}"
                focus = "global"
        if (not (context_id in SynData.INSTANCE.data.keys())):
            SynData.INSTANCE.data[context_id] = {}
            SynData.INSTANCE.data[context_id].update({"meta":{"localization" : localization, "name" : context, "focus" : focus.lower()}})
        SynData.INSTANCE.context = context_id
    
    @staticmethod
    @keyword(tags=["Management"])
    def Release_Context():
        """
        This keyword removes the context.

        After calling this keyword, it is ensured that the keywords that 
        generate test cases do not access already stored data. Data consistency 
        is also not guaranteed if no context is set.
        """
        SynData.INSTANCE.context = None

    @staticmethod
    @keyword(tags=["Management"])
    def Get_Context() -> str:
        """
        The keyword returns the name of the context, if a context is set.
        
        If no context is set, the value ``None`` is returned.
        """
        if(None == SynData.INSTANCE.context):
            # In this case, no context is set and therefore None is returned.
            return None
        # return self.context
        if (None != SynData.INSTANCE.context):
            context_name = SynData.INSTANCE.data.get(SynData.INSTANCE.context).get("meta").get("name")
            context_focus = SynData.INSTANCE.data.get(SynData.INSTANCE.context).get("meta").get("focus")
            if(       (f"{SynData.INSTANCE.get_current_test_suite()}.{SynData.INSTANCE.get_current_test_case()}.{context_name}" == SynData.INSTANCE.context)
                  and ("test" == context_focus)):
                # In this case, a context was detected that exactly matches the test case currently being executed.
                return context_name
            elif(     (f"{SynData.INSTANCE.get_current_test_suite()}.{context_name}" == SynData.INSTANCE.context)
                  and ("suite" == context_focus)):
                # In this case, a context was detected that exactly matches the test suite currently being executed.
                return context_name
            elif(     (f"global.{context_name}" == SynData.INSTANCE.context)
                  and ("global" == context_focus)):
                # In this case, a context with a global focus was detected.
                return context_name
            else:
                # In this case, a context is set, but the context has a focus 
                # that does not match either the test case or the test suite.
                # Consequently, the value None is returned.
                return None
        else: 
            # In this case, no context is set and therefore None is returned.
            return None

    #   ========================================================================
    #       Keywords for Test Data Domain: Address Data
    #   ========================================================================

    @staticmethod
    @keyword(tags=["Address"])
    def Get_Address() -> str:
        """
        The keyword returns an address as a string with a line break.
        
        An address usually consists of two lines with the following content:
        - Street name and house number
        - Postal code and city
        
        An example of a German address could be: 
        | Friedrich-Neukirchen-Straße 53b
        | 50181 Bedburg      
        """
        return SynData.INSTANCE.ibe.execute(SynData.INSTANCE, SynData.INSTANCE.get_current_localization(), "Get Address", "address.address", {})

    @staticmethod
    @keyword(tags=["Address"])
    def Get_Address_And_Country() -> str:
        """
        The keyword returns an address as a string with two line breaks.
        
        An address usually consists of two lines with the following content:
        - Street name and house number
        - Postal code and city
        This keywords adds the name of the country in the third line.
        
        An example of a German address could be: 
        | Friedrich-Neukirchen-Straße 53b
        | 50181 Bedburg      
        | Deutschland
        """
        return SynData.INSTANCE.ibe.execute(SynData.INSTANCE, SynData.INSTANCE.get_current_localization(), "Get Address And Country", "address.address_country", {})

    @staticmethod
    @keyword(tags=["Address"])
    def Get_Street_And_House_Number() -> str:
        """
        The keyword provides a street name and a house number.
        """
        return SynData.INSTANCE.ibe.execute(SynData.INSTANCE, SynData.INSTANCE.get_current_localization(), "Get Street And House Number", "address.street_address", {})

    @staticmethod
    @keyword(tags=["Address"])
    def Get_Street() -> str:
        """
        The keyword provides a street name with a house number.
        """
        return SynData.INSTANCE.ibe.execute(SynData.INSTANCE, SynData.INSTANCE.get_current_localization(), "Get Street", "address.street", {})

    @staticmethod
    @keyword(tags=["Address"])
    def Get_House_Number() -> str:
        """
        The keyword provides a house number.
        """
        return SynData.INSTANCE.ibe.execute(SynData.INSTANCE, SynData.INSTANCE.get_current_localization(), "Get House Number", "address.house_number", {})

    @staticmethod
    @keyword(tags=["Address"])
    def Get_Postcode_And_City() -> str:
        """
        The keyword provides a string containing a postal code and a city.
        """
        return SynData.INSTANCE.ibe.execute(SynData.INSTANCE, SynData.INSTANCE.get_current_localization(), "Get Postcode And City", "address.postcode_city", {})

    @staticmethod
    @keyword(tags=["Address"])
    def Get_Postcode() -> str:
        """
        The keyword returns a string containing a postal code.
        """
        return SynData.INSTANCE.ibe.execute(SynData.INSTANCE, SynData.INSTANCE.get_current_localization(), "Get Postcode", "address.postcode", {})

    @staticmethod
    @keyword(tags=["Address"])
    def Get_City() -> str:
        """
        The keyword provides a string containing the name of a city.
        """
        return SynData.INSTANCE.ibe.execute(SynData.INSTANCE, SynData.INSTANCE.get_current_localization(), "Get City", "address.city", {})

    @staticmethod
    @keyword(tags=["Address"])
    def Get_State() -> str:
        """
        The keyword contains the name of a state.

        Depending on the location, the keyword may return a different result. 

        Germany is divided into 16 federal states. The keyword returns the name 
        of one of these federal states and, if a context is set, the return 
        value is consistent with other address data.
        """
        return SynData.INSTANCE.ibe.execute(SynData.INSTANCE, SynData.INSTANCE.get_current_localization(), "Get State", "address.state", {})

    @staticmethod
    @keyword(tags=["Address"])
    def Get_Country() -> str:
        """
        The keyword returns the name of a country in the local language.

        If a context is set, the country that matches the localization is 
        returned. Otherwise, the address data would not be consistent.

        If the keyword is to return any country names, it must be used without 
        context.
        """
        return SynData.INSTANCE.ibe.execute(SynData.INSTANCE, SynData.INSTANCE.get_current_localization(), "Get Country", "address.country", {})

    @staticmethod
    @keyword(tags=["Address"])
    def Get_Country_Code() -> str:
        """
        The keyword provides a country code in the form of two uppercase letters.
        
        If a context is set and a specialized generator is used, the identifier 
        of the country that matches the localization is provided.
        
        If no context is set, a random code is generated that matches a country.        
        """
        return SynData.INSTANCE.ibe.execute(SynData.INSTANCE, SynData.INSTANCE.get_current_localization(), "Get Country Code", "address.country_code", {})

    #   ========================================================================
    #       Keywords for Test Data Domain: Personal Data
    #   ========================================================================

    @staticmethod
    @keyword(tags=["Person"])
    def Get_Name(sex: Literal["f", "m", "d", "*"] ="*") -> str:
        """
        The keyword provides a name consisting of a first name and a last name.
        
        | =Arguments= | =Descripion= |
        | ``sex``     | This parameter can be used to specify the gender, which affects the first name. The permitted values are ``m`` for male, ``f`` for female, ``d`` for diverse, and ``*`` for no gender specified. |
        """
        if ( None == SynData.Get_Context() ):
            localization = SynData.INSTANCE.default_localization
        else:
            localization = SynData.INSTANCE.data.get(SynData.INSTANCE.context).get("meta").get("localization")
        return SynData.INSTANCE.ibe.execute(SynData.INSTANCE, localization, "Get Name", "person.name", {"sex":sex})

    @staticmethod    
    @keyword(tags=["Person"])
    def Get_First_Name(sex: Literal["f", "m", "d", "*"] ="*") -> str:
        """
        The keyword provides a first name.
        
        | =Arguments= | =Descripion= |
        | ``sex``     | This parameter can be used to specify the gender, which affects the first name. The permitted values are ``m`` for male, ``f`` for female, ``d`` for diverse, and ``*`` for no gender specified. |
        """
        if ( None == SynData.Get_Context() ):
            localization = SynData.INSTANCE.default_localization
        else:
            localization = SynData.INSTANCE.data.get(SynData.INSTANCE.context).get("meta").get("localization")
        return SynData.INSTANCE.ibe.execute(SynData.INSTANCE, localization, "Get First Name", "person.first_name", {"sex":sex})
    
    @staticmethod
    @keyword(tags=["Person"])
    def Get_Last_Name() -> str:
        """
        The keyword provides a last name.
        """
        return SynData.INSTANCE.ibe.execute(SynData.INSTANCE, SynData.INSTANCE.get_current_localization(), "Get Last Name", "person.last_name", {})

    #   ========================================================================
    #       Methods for internal management                 @not_keyword
    #   ========================================================================
    
    @not_keyword
    def set_configuration(self, mode: Literal["default", "replay"] = "default", localization: str ="en_US", logging: bool =False, logfile: str =None , replay_file: str = None):
        self.mode = SynData.MODE_DEF
        self.default_localization = localization
        self.logging = (True == logging)
        match(mode):
            case "default":
                self.replayfile = None
            case "replay":
                if(None == replay_file):
                    self.add_rbt_log_message("The keyword Set Mode expects a full qualified path in parameter replay_file!", "ERROR")
                elif(not(os.path.isfile(replay_file))) : 
                    self.add_rbt_log_message(f"A file with the path '{replay_file}' could not be found!", "ERROR")
                else:
                    self.mode = SynData.MODE_REP
                    self.replayfile = replay_file        
        if (self.logging):
            path = self.get_rbt_variable_value("${OUTPUT DIR}")
            if (None == logfile):
                file_name = datetime.datetime.now().strftime("SynData-%Y%m%d-%H%M%S")
                self.logfile = f"{path}/{file_name}.csv"
            else:
                if (-1 == logfile.find(".")):
                    self.logfile = f"{path}/{logfile}.csv"
                else:
                    self.logfile = f"{path}/{logfile}"
            self.logdata = pd.DataFrame(None, columns=["timestamp", "item", "value", "test_suite", "test_case", "keyword"])

    @not_keyword
    def get_mode(self) -> int:
        return self.mode
    
    @not_keyword
    def get_item(self, item) -> str:
        if ( None == self.context ):
            return None
        else: 
            return self.data[self.context].get(item)

    @not_keyword
    def add_item(self, item, value):
        if( None != self.context ):
            self.data[self.context].update({item: value})

    @not_keyword
    def add_log_entry(self, keyword, item, value):
        if ((self.logging) and (None != self.logfile)):
            if(0 == len(self.logdata)):
                if(os.path.exists(self.logfile)):
                    self.logdata = pd.read_csv(self.logfile, index_col="index")
            ts = datetime.datetime.now().strftime("%Y-%m-%d %X") + ("-" if time.timezone > 0 else "+") + time.strftime("%H:%M", time.gmtime(abs(time.timezone)))
            suite = self.get_rbt_variable_value("${SUITE NAME}")
            test_case = self.get_rbt_variable_value("${TEST NAME}")
            self.logdata.loc[len(self.logdata)] = [ts, item, value, suite, test_case, keyword]
            self.logdata.to_csv(self.logfile, index_label="index")

    @not_keyword
    def add_rbt_log_message(self, message: str, level):
        if(None == self.rbt_bi):
            self.rbt_bi = BuiltIn()
        self.rbt_bi.log(message, level=level)


    @not_keyword
    def get_rbt_variable_value(self, variable: str) -> str:
        if(None == self.rbt_bi):
            self.rbt_bi = BuiltIn()
        return self.rbt_bi.get_variable_value(variable)

    @not_keyword
    def get_current_test_suite(self) -> str:
        return self.get_rbt_variable_value("${SUITE NAME}")

    @not_keyword
    def get_current_test_case(self) -> str:    
        return self.get_rbt_variable_value("${TEST NAME}")
    
    @not_keyword
    def get_current_localization(self) -> str:
        if ( None == SynData.Get_Context() ):
            return self.default_localization
        else:
            return self.data.get(self.context).get("meta").get("localization")

    
    def get_replay_file(self) -> str:
        return self.replayfile


    @not_keyword
    def get_common_country_name(self, item_data:dict, language: str) -> str:
        return Country.get_country_name(item_data, language)
        
    @not_keyword
    def get_common_country_code(self, item_data:dict, code: Literal["ALPHA-2", "ALPHA-3"] ="ALPHA-2") -> str:
        return Country.get_country_code(item_data, code)
        
    # @not_keyword
    # def Hello_World(self):
    #     """ Bei diesem Schlüsselwort ist der Name verdächtig. ;-) Es ist das erste Schlüsselwort und
    #         kann nicht einmal "Hallo" sagen."""
    #     pass

    # @not_keyword
    # def Create_Person(self, gender="any", forenames=1, forename_hyphen=False, compound_name=False, birth_name=False):
    #     """Lorem ipsum dolor it."""
    #     person_data = {}
    #     person_data.update({"meta":{"type":"physical person", "mode":"synthetic", "category":"person"}})
    #     if (self.is_male(gender)):
    #         person_data.update({"forename" : self.get_random_male_forename(forenames, forename_hyphen)})
    #         person_data.update({"gender": "male"})
    #     elif (self.is_female(gender)):
    #         person_data.update({"forename" : self.get_random_female_forename(forenames, forename_hyphen)})
    #         person_data.update({"gender": "female"})
    #     elif (self.is_third_gender(gender)):
    #         if(0 == random.randrange(1, 1000) % 2):
    #             person_data.update({"forename": self.get_random_male_forename(forenames, forename_hyphen)})
    #         else:
    #             person_data.update({"forename": self.get_random_female_forename(forenames, forename_hyphen)})
    #         person_data.update({"gender" : "third sex"})
    #     else:
    #         if(0 == random.randrange(1, 1000) % 2):
    #             person_data.update({"forename": self.get_random_male_forename(forenames, forename_hyphen)})
    #             person_data.update({"gender": "male"})
    #         else:
    #             person_data.update({"forename": self.get_random_female_forename(forenames, forename_hyphen)})
    #             person_data.update({"gender": "female"})
    #     person_data.update({"surname" : self.get_random_surname(compound_name)})
    #     if (birth_name):
    #         if (compound_name) :
    #             person_data.update({"birthname": person_data.get("surname").split("-",1)[0]})
    #         else:
    #             person_data.update({"birthname": self.get_random_surname(False)})
    #     return person_data

    # @not_keyword
    # def Add_Address(self, person_data, country="de", postcode_min="01000", postcode_max="99999", housenumber=0, housenumber_max=99 ):
    #     """Lorem ipsum dolor it."""
    #     if self.de_locations == None:
    #         self.de_locations = utils.support_de.MailingAddressGermany()
    #     person_data = self.de_locations.add_location(person_data)
    #     return person_data

    # @not_keyword
    # def Add_Address_By_Filter(self, person_data, filter, address_attribute="address"):
    #     """Lorem ipsum dolor it."""
    #     if self.de_locations == None:
    #         self.de_locations = utils.support_de.MailingAddressGermany()
    #     retval=person_data
    #     country=str(filter.get("country", {}).get("value", "de")).lower()
    #     if (country in ["de", "germany", "deutschland"]):
    #         retval=self.de_locations.add_filtered_location(person_data, filter, address_attribute)
    #     return retval

    # @not_keyword
    # def Get_Filtered_Locations(self, filter={}):
    #     """Lorem ipsum dolor it."""
    #     if self.de_locations == None:
    #         self.de_locations = utils.support_de.MailingAddressGermany()
    #     return self.de_locations.get_locations_filtered_by_postcode(self.de_locations.cities, filter)

    # @not_keyword
    # def Add_Cellphone_Number(self, item, filter={}, information_path="communication.cellphone"):
    #     """Lorem ipsum dolor it."""
    #     if self.de_communication == None:
    #         self.de_communication = utils.support_de.TelecommunicationGermany()
    #     return self.de_communication.add_cellphone_number(item, filter, information_path)


    # @not_keyword
    # def Add_Landline_Number(self, item, filter={}, information_path="communication.landline"):
    #     """Lorem ipsum dolor it."""
    #     if self.de_communication == None:
    #         self.de_communication = utils.support_de.TelecommunicationGermany()
    #     return self.de_communication.add_landline_number(item, filter, information_path)

    # @not_keyword
    # def is_male(self, gender):
    #     """Lorem ipsum dolor it."""
    #     return gender.lower() in ["m", "mr", "male", "männlich"]

    # @not_keyword
    # def is_female(self, gender):
    #     """Lorem ipsum dolor it."""
    #     return gender.lower() in ["w", "mrs", "f", "female", "weiblich"]

    # @not_keyword
    # def is_third_gender(self, gender):
    #     """Lorem ipsum dolor it."""
    #     return gender.lower() in ["d", "mx", "third sex", "third gender", "divers"]

    # @not_keyword
    # def get_random_male_forename(self, forenames, hyphen):
    #     """Lorem ipsum dolor it."""
    #     retval = self.forenames_male[random.randrange(0,len(self.forenames_male))]
    #     for i in range(1, forenames):
    #         if (hyphen):
    #             if (i > retval.count("-")):
    #                 retval = retval + "-" + self.forenames_male[random.randrange(0,len(self.forenames_male))]
    #         else:
    #             retval = retval + " " + self.forenames_male[random.randrange(0, len(self.forenames_male))]
    #     return retval

    # @not_keyword
    # def get_random_female_forename(self, forenames, hyphen):
    #     """Lorem ipsum dolor it."""
    #     retval = self.forenames_female[random.randrange(0,len(self.forenames_female))]
    #     for i in range(1, forenames):
    #         if (hyphen):
    #             if (i > retval.count("-")):
    #                 item = self.forenames_female[random.randrange(0,len(self.forenames_female))]
    #                 while 0 != item.count("-"):
    #                     item = self.forenames_female[random.randrange(0,len(self.forenames_female))]
    #                 retval = retval + "-" + item
    #         else:
    #             retval = retval + " " + self.forenames_female[random.randrange(0,len(self.forenames_female))]
    #     return retval

    # @not_keyword
    # def get_random_surname(self, compound_name):
    #     """Lorem ipsum dolor it."""
    #     retval = self.surnames[random.randrange(0,len(self.surnames))]
    #     if (compound_name):
    #         retval = retval + "-" + self.surnames[random.randrange(0,len(self.surnames))]
    #     return retval

    # #de_locations = utils.support_de.MailingAddressGermany()
    # #de_communication = utils.support_de.TelecommunicationGermany()

    # de_locations = None
    # de_communication = None

