# SynData for Robot Framework

The purpose of this library is to generate synthetic test data that is as 
consistent as possible. The library achieves this by providing specialized 
generators for different countries, which are used to generate the test data. 

In addition, there are two functions that characterize this library:
  - The context defines a "data space" in which previously generated data is 
    stored, so that repeating a keyword returns the value of the first call.
  - The library logs the generated data in a separate file, and a corresponding 
    switch allows the library to use a log file as a data source. This allows, 
    for example, a test case to be re-executed with the data from a previous 
    execution. To do this, only the import statement of the library needs to be 
    changed, and the test case can remain unchanged.

See [keyword documentation](https://dschweie.github.io/robotframework-syndata/SynData.html) for more details.

# Installation instructions

The library can be installed as usual using pip:
````Batch
pip install robotframework-syndata
````

# Examples

... to follow at a later date

# Notes on the structure of the library

The library should support the concept of localization from the outset so that 
test data can be generated specifically for a country. Since only a specialized 
generator is initially provided for Germany, there is a general generator that 
uses Faker to generate test data.

The generated data should be consistent. When using a context, a stored date 
may need to be returned, and in some cases, only data from a defined data 
source should be returned and no data should be generated at all. This short 
list makes it clear that there are a number of factors that determine whether a 
date is generated or taken from a data source. In order to largely eliminate 
sources of error, the dependencies are modeled in decision tables and the 
Python code is generated from the decision tables.

This project uses the [LF-ET](https://www.lohrfink.de/en/solutions/lf-et/)
decision table editor from 
[LOHRFINK software engineering GmbH & Co. KG](https://www.lohrfink.de/en/company/about-us/) 
to create and maintain the decision tables. 
In [LF-ET](https://www.lohrfink.de/en/solutions/lf-et/), the rules can be 
filtered in almost any way, so that "excerpts" from a large set of 
rules can also be analyzed. 
[LF-ET](https://www.lohrfink.de/en/solutions/lf-et/) provides automated 
verification of completeness, absence of redundancies and contradictions. From 
such a decision table, [LF-ET](https://www.lohrfink.de/en/solutions/lf-et/) can 
generate the corresponding source code for different programming languages, 
which is also used in this project. 

The classes generated from a decision table are always introduced with the same 
comment lines:

````Python
# *** WARNING: DO NOT MODIFY *** This is a generated Python source code!
#
# Generated by LF-ET 2.4.1 (260127a), https://www.lohrfink.de/lfet
````

This project is supported by 
[LOHRFINK software engineering GmbH & Co. KG](https://www.lohrfink.de/en/company/about-us/), 
and a current version of the decision table editor LF-ET is available at the 
following link: https://www.lohrfink.de/lfet/lfet.latest.inst

The specialized generators and the required data are stored in separate 
packages that can be assigned using the name of the region. For Germany, the 
code and data can be found in the folder ``src/SynData/de_DE``.

# Special thanks

I would like to thank 
[LOHRFINK software engineering GmbH & Co. KG](https://www.lohrfink.de/en/company/about-us/) 
for providing a project license for this project. Thanks to the project license 
for the [LF-ET](https://www.lohrfink.de/en/solutions/lf-et/) 
decision table editor, the process logic for generation can be modeled in 
decision tables and the corresponding Python code can be generated.

This library is also the result of constructive discussions with the 
Robot Framework community. Special thanks go to Ren√©, who gave me the idea that 
the library should log the generated data and that the log should be used as a 
source for repeating test cases.